{% extends 'base.html' %}
{% load static %}
{% load static GPTrivia_extras %}


{% block extra_css %}
  <link rel="stylesheet" href="{% static 'GPTrivia/css/scoresheet.css' %}">
{% endblock %}

{% block extra_meta %}
    <meta name="theme-color" content="#1e7662">
    <link href="{% static 'DataTables/datatables.min.css' %}" rel="stylesheet"/>
    <script src="{% static 'DataTables/datatables.min.js' %}"></script>

    <script src="{% static '/jquery-tabledit-1.2.3/jquery.tabledit.min.js' %}"></script>    <!-- Include necessary extensions here -->
    <script src="{% static 'DataTables/Buttons-2.3.6/js/dataTables.buttons.min.js' %}"></script>
    <script src="{% static 'DataTables/ColReorder-1.6.2/js/dataTables.colReorder.min.js' %}"></script>
    <script src="{% static 'DataTables/AutoFill-2.5.3/js/dataTables.autoFill.min.js' %}"></script>
    <script src="{% static 'DataTables/Responsive-2.4.1/js/dataTables.responsive.min.js' %}"></script>


    {% csrf_token %}
    <meta name="csrf-token" content="{{ csrf_token }}">
    <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js"></script>

{% endblock %}

{% block content %}

    <div id="react-scoresheet"></div>

    <script src="{% static 'scoresheet/build/static/js/main.95f57237.js' %}"></script>
    <button id="animate-btn">Animate</button>

    <button id="magic-button">Click me!</button>
    <div id="star-overlay"></div>
    
    <div id="elephant-track">
      <div id="elephant-wrapper">
        <div id="elephant"></div>
      </div>
    </div>

    <div id="snake-track">
      <div id="snake-wrapper">
        <div id="snakey"></div>
      </div>
    </div>
    
{#    <button id="let-elephant-go">Swoop!</button>#}
    <button id="let-snake-go">Swoop!</button>
    <button id="let-snakes-go">Release the snakes</button>

    
    <script>
    // create the sky once
    function ensureSky(){
      let sky = document.getElementById('snake-sky');
      if (!sky){ sky = document.createElement('div'); sky.id = 'snake-sky'; document.body.appendChild(sky); }
      return sky;
    }
    function rand(min, max){ return min + Math.random()*(max-min); }

    function launchFleet(count=12){
      const sky = ensureSky();
      for (let i=0; i<count; i++){
        const s = document.createElement('div');
        s.className = 'snake';
        if (Math.random() < 0.5) s.classList.add('left');         // random direction
        s.style.setProperty('--y', `${rand(5, 90)}vh`);           // vertical track
        s.style.setProperty('--scale', rand(0.7, 1.4).toFixed(2)); // size variance
        s.style.setProperty('--dur', `${rand(6, 14)}s`);           // speed variance
        s.style.setProperty('--delay', `${rand(0, 2)}s`);          // stagger

        // z-index layering
        s.style.zIndex = String(Math.floor(rand(1, 9)));

        // remove after flight completes
        s.addEventListener('animationend', (e) => {
          if (e.animationName === 'fly-right' || e.animationName === 'fly-left') s.remove();
        });

        sky.appendChild(s);
      }
    }

    document.getElementById('let-snakes-go').addEventListener('click', () => {
      launchFleet(16); // pick your fleet size
    });

    document.getElementById('let-elephant-go').addEventListener('click', () => {
      const wrap = document.getElementById('elephant-wrapper');
      wrap.style.animation = 'none';     // reset
      void wrap.offsetWidth;             // force reflow
      wrap.style.animation = 'walk-x 12s linear 1 forwards';
    });

    document.getElementById('let-snake-go').addEventListener('click', () => {
      const wrap = document.getElementById('snake-wrapper');
      wrap.style.animation = 'none';     // reset
      void wrap.offsetWidth;             // force reflow
      wrap.style.animation = 'walk-x 4s linear 1 forwards';
    });
    </script>

    <script src="{% static 'GPTrivia/js/stars.js' %}"></script>
    <script>
    // Run on click
    document.getElementById('animate-btn').addEventListener('click', () => {
      // scope to whole page: '*'  or just the scoresheet: '#react-scoresheet *'
      chaosColors({ selector: '*', toMs: 400, backMs: 1600 });
    });

    function randomColor(){
      // bright but readable
      const h = Math.floor(Math.random()*360);
      return `hsl(${h} 80% 55%)`;
    }

    function chaosColors({selector='*', toMs=400, backMs=1600} = {}){
      const els = Array.from(document.querySelectorAll(selector))
        .filter(el => el.nodeType === 1 && !['SCRIPT','STYLE','LINK','META'].includes(el.tagName));

      const saved = new WeakMap();

      // phase 1: transition to random colors
      for (const el of els){
        const cs = getComputedStyle(el);
        saved.set(el, {
          color: cs.color,
          bg: cs.backgroundColor,
          border: cs.borderColor,
          fill: cs.fill,
          stroke: cs.stroke,
          transition: el.style.transition
        });

        el.style.transition = [
          `color ${toMs}ms`,
          `background-color ${toMs}ms`,
          `border-color ${toMs}ms`,
          `fill ${toMs}ms`,
          `stroke ${toMs}ms`
        ].join(', ');

        // set randoms only where it makes sense
        el.style.color = randomColor();
        if (cs.backgroundColor !== 'rgba(0, 0, 0, 0)' && cs.backgroundColor !== 'transparent')
          el.style.backgroundColor = randomColor();
        if (parseFloat(cs.borderWidth) > 0) el.style.borderColor = randomColor();
        if (cs.fill   && cs.fill   !== 'none') el.style.fill   = randomColor(); // SVG
        if (cs.stroke && cs.stroke !== 'none') el.style.stroke = randomColor(); // SVG
      }

      // phase 2: transition back
      setTimeout(() => {
        for (const el of els){
          const rec = saved.get(el);
          el.style.transition = [
            `color ${backMs}ms`,
            `background-color ${backMs}ms`,
            `border-color ${backMs}ms`,
            `fill ${backMs}ms`,
            `stroke ${backMs}ms`
          ].join(', ');

          el.style.color = rec.color;
          el.style.backgroundColor = rec.bg;
          el.style.borderColor = rec.border;
          el.style.fill = rec.fill;
          el.style.stroke = rec.stroke;

          // restore original transition after it finishes
          setTimeout(() => { el.style.transition = rec.transition; }, backMs);
        }
      }, toMs);
    }

    </script>

{% endblock %}